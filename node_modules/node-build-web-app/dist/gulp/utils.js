"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _gulpNotify = require("gulp-notify");

var _gulpNotify2 = _interopRequireDefault(_gulpNotify);

var _gulpUtil = require("gulp-util");

var _gulpUtil2 = _interopRequireDefault(_gulpUtil);

var _gulpPlumber = require("gulp-plumber");

var _gulpPlumber2 = _interopRequireDefault(_gulpPlumber);

var _karma = require("karma");

var _karma2 = _interopRequireDefault(_karma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KarmaServer = _karma2.default.Server;

var exitOnError = false;

var reportError = function reportError(error) {
    var lineNumber = error.lineNumber ? "LINE " + error.lineNumber + " -- " : "";
    var report = "";
    var chalk = _gulpUtil2.default.colors.white.bgRed;

    (0, _gulpNotify2.default)({
        title: "Task Failed [" + error.plugin + "]",
        message: lineNumber + " See console.",
        sound: true

    }).write(error);

    report += chalk("TASK:") + " [" + error.plugin + "]\n";
    report += chalk("ISSUE:") + " " + error.message + "\n";

    if (error.lineNumber) {
        report += chalk("LINE:") + " " + error.lineNumber + "\n";
    }

    if (error.fileName) {
        report += chalk("FILE:") + " " + error.fileName + "\n";
    }

    console.error(report);

    if (exitOnError) {
        throw new Error("Error: ", error);
    } else {
        undefined.emit("end");
    }
};

var exclude = function exclude(providedPath) {
    return "!" + providedPath;
};

var filterEmptyDirectories = function filterEmptyDirectories(es) {
    return es.map(function (file, cb) {
        if (file.stat.isFile()) {
            return cb(null, file);
        } else {
            return cb();
        }
    });
};

var validateArgument = function validateArgument(arg, errorMessage) {
    errorMessage = errorMessage || "the provided argument cannot be null or undefined!";

    if (arg === null || arg === undefined) {
        throw new TypeError(errorMessage);
    }
};

var validateGulpObject = function validateGulpObject(obj) {
    validateArgument(obj);
    validateArgument(obj.tasks, "the provided argument must be a gulp instance!");
};

var validateGulpObjectIsConfigured = function validateGulpObjectIsConfigured(obj) {
    var notCorrectlyConfiguredErrorMessage = "the provided argument is a valid gulp object but it isn't configured properly. You need to invoke the configureGulpObject utility function before passing it to the tasks!";

    validateGulpObject(obj);
    validateArgument(obj.tasks.help, notCorrectlyConfiguredErrorMessage);
    validateArgument(obj.plumbedSrc, notCorrectlyConfiguredErrorMessage);
};

var configureGulpObject = function configureGulpObject(obj, options) {
    validateGulpObject(obj);
    var help = require("gulp-help");

    var configuredGulpObject = help(obj);

    configuredGulpObject.options = options;
    configuredGulpObject.plumbedSrc = function () {
        return configuredGulpObject.src.apply(configuredGulpObject, arguments).pipe((0, _gulpPlumber2.default)({
            errorHandler: reportError
        }));
    };

    return configuredGulpObject;
};

var mergeOptions = function mergeOptions() {
    var obj1 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var obj2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var retVal = {};

    for (var attrname in obj1) {
        if (obj1.hasOwnProperty(attrname)) {
            retVal[attrname] = obj1[attrname];
        }
    }

    for (var _attrname in obj2) {
        if (obj2.hasOwnProperty(_attrname)) {
            retVal[_attrname] = obj2[_attrname];
        }
    }

    return retVal;
};

var getJavaScriptFolder = function getJavaScriptFolder(gulp, config) {
    if (gulp.options.folders) {
        return [gulp.options.folders.app + config.globs.scripts.javascript];
    } else {
        return config.javascript.src;
    }
};

var getTypeScriptFolder = function getTypeScriptFolder(gulp, config) {
    if (gulp.options.folders) {
        return [gulp.options.folders.app + config.globs.scripts.javascript];
    } else {
        return config.javascript.src;
    }
};

var getCssFolder = function getCssFolder(gulp, config) {
    if (gulp.options.folders) {
        return [gulp.options.folders.app + config.globs.styles.css, gulp.options.folders.app + config.globs.styles.sass];
    } else {
        return config.styles.src;
    }
};

var getKarmaServer = function getKarmaServer(config, callback) {
    return new KarmaServer({
        configFile: config.path,
        singleRun: config.singleRun
    }, callback).start();
};

exports.default = {
    exclude: exclude,
    reportError: reportError,
    filterEmptyDirectories: filterEmptyDirectories,
    validateArgument: validateArgument,
    validateGulpObjectIsConfigured: validateGulpObjectIsConfigured,
    configureGulpObject: configureGulpObject,
    mergeOptions: mergeOptions,
    getJavaScriptFolder: getJavaScriptFolder,
    getTypeScriptFolder: getTypeScriptFolder,
    getCssFolder: getCssFolder,
    getKarmaServer: getKarmaServer
};